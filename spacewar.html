<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space War - Enhanced Graphics</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Malgun Gothic', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            pointer-events: none;
            z-index: 10;
        }
        .stat-bar {
            background: rgba(0,0,0,0.8);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 10px;
            display: inline-block;
            margin-right: 20px;
            box-shadow: 0 0 15px rgba(0,255,255,0.3);
        }
        .stat-label { color: #00ffff; font-size: 14px; margin-bottom: 5px; }
        .bar {
            width: 200px; height: 20px; background: #333;
            border-radius: 5px; overflow: hidden; border: 1px solid #666;
        }
        .bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00cc00);
            transition: width 0.3s;
            box-shadow: 0 0 10px rgba(0,255,0,0.5);
        }
        .exp-bar .bar-fill {
            background: linear-gradient(90deg, #ffff00, #ff9900);
            box-shadow: 0 0 10px rgba(255,255,0,0.5);
        }
        #levelUpModal {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            border: 3px solid #00ffff; border-radius: 15px;
            padding: 30px; display: none; z-index: 100;
            max-width: 1000px; pointer-events: auto;
            box-shadow: 0 0 40px rgba(0,255,255,0.6);
        }
        .upgrade-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 15px; margin-top: 20px;
        }
        .upgrade-card {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid #00ffff; border-radius: 10px;
            padding: 15px; cursor: pointer; transition: all 0.3s;
        }
        .upgrade-card:hover {
            transform: scale(1.05);
            border-color: #00ff00;
            box-shadow: 0 0 20px rgba(0,255,255,0.5);
        }
        .upgrade-icon { font-size: 32px; margin-bottom: 8px; }
        .upgrade-name {
            color: #00ffff; font-size: 15px;
            font-weight: bold; margin-bottom: 8px;
        }
        .upgrade-desc { color: #aaa; font-size: 12px; }
        .level-display { color: #ffff00; font-size: 13px; margin-top: 8px; }
        #gameOver {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            border: 3px solid #ff0000; border-radius: 15px;
            padding: 40px; display: none; z-index: 100;
            text-align: center;
            box-shadow: 0 0 40px rgba(255,0,0,0.6);
        }
        .btn {
            background: linear-gradient(135deg, #00ffff, #0099ff);
            border: none; color: #000;
            padding: 15px 30px; font-size: 18px;
            font-weight: bold; border-radius: 10px;
            cursor: pointer; margin: 10px; transition: all 0.3s;
        }
        .btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0,255,255,0.8);
        }
        #stats {
            position: fixed; top: 80px; left: 20px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #00ffff; border-radius: 10px;
            padding: 15px; font-size: 14px; color: #0ff;
            box-shadow: 0 0 15px rgba(0,255,255,0.3);
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <div id="ui">
        <div class="stat-bar">
            <div class="stat-label">HP: <span id="hpText">150/150</span></div>
            <div class="bar"><div class="bar-fill" id="hpBar" style="width: 100%"></div></div>
        </div>
        <div class="stat-bar exp-bar">
            <div class="stat-label">Í≤ΩÌóòÏπò: <span id="expText">0/100</span></div>
            <div class="bar"><div class="bar-fill" id="expBar" style="width: 0%"></div></div>
        </div>
    </div>
    
    <div id="stats">
        <div>Î†àÎ≤®: <span id="levelText">1</span></div>
        <div>ÏãúÍ∞Ñ: <span id="timeText">00:00</span></div>
        <div>Ï≤òÏπò: <span id="killText">0</span></div>
    </div>
    
    <div id="levelUpModal">
        <h2 style="color: #00ffff; text-align: center; margin-bottom: 20px;">‚¨ÜÔ∏è Î†àÎ≤® ÏóÖ! ÏóÖÍ∑∏Î†àÏù¥Îìú ÏÑ†ÌÉù</h2>
        <div class="upgrade-grid" id="upgradeOptions"></div>
    </div>
    
    <div id="gameOver">
        <h1 style="color: #ff0000; margin-bottom: 20px;">üí• Ï†ÑÌï® ÌååÍ¥¥!</h1>
        <div style="font-size: 24px; margin-bottom: 20px;">
            <div>ÏÉùÏ°¥ ÏãúÍ∞Ñ: <span id="finalTime" style="color: #ffff00;">00:00</span></div>
            <div>Ï¥ù Ï≤òÏπò: <span id="finalKills" style="color: #00ff00;">0</span></div>
            <div>ÏµúÏ¢Ö Î†àÎ≤®: <span id="finalLevel" style="color: #00ffff;">1</span></div>
        </div>
        <button class="btn" onclick="location.reload()">üîÑ Îã§Ïãú ÏãúÏûë</button>
    </div>

    <script>
        class GameScene extends Phaser.Scene {
            constructor() {
                super('GameScene');
            }

            preload() {
                // ÌÖçÏä§Ï≤ò ÏÉùÏÑ±
                this.createTextures();
            }

            createTextures() {
                // ÌîåÎ†àÏù¥Ïñ¥ Ïö∞Ï£ºÏÑ†
                const ship = this.add.graphics();
                ship.fillStyle(0x00ffff);
                ship.fillTriangle(20, 0, 0, 40, 40, 40);
                ship.fillStyle(0x0088ff);
                ship.fillRect(15, 10, 10, 15);
                ship.fillStyle(0xff6600);
                ship.fillCircle(10, 35, 4);
                ship.fillCircle(30, 35, 4);
                ship.generateTexture('player', 40, 40);
                ship.destroy();

                // Î≥Ñ Î∞∞Í≤ΩÏö©
                const star = this.add.graphics();
                star.fillStyle(0xffffff);
                star.fillCircle(2, 2, 2);
                star.generateTexture('star', 4, 4);
                star.destroy();

                // ÌååÌã∞ÌÅ¥
                const particle = this.add.graphics();
                particle.fillStyle(0xffffff);
                particle.fillCircle(4, 4, 4);
                particle.generateTexture('particle', 8, 8);
                particle.destroy();
            }

            create() {
                // Î∞∞Í≤Ω Î†àÏù¥Ïñ¥
                this.createBackground();
                
                // Í≤åÏûÑ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
                this.initGame();
                
                // ÌîåÎ†àÏù¥Ïñ¥
                this.player = this.add.sprite(config.width / 2, config.height / 2, 'player');
                this.player.setScale(1.5);
                
                // ÏóîÏßÑ ÌååÌã∞ÌÅ¥
                this.engineParticles = this.add.particles(0, 0, 'particle', {
                    speed: { min: 50, max: 100 },
                    scale: { start: 0.3, end: 0 },
                    tint: [0xff6600, 0xff9900, 0xffaa00],
                    lifespan: 300,
                    frequency: 30,
                    follow: this.player,
                    followOffset: { y: 15 }
                });

                // Í∑∏Î£π
                this.enemies = this.add.group();
                this.projectiles = this.add.group();
                this.xpOrbs = this.add.group();
                this.explosions = this.add.group();

                // ÌÉÄÏù¥Î®∏
                this.time.addEvent({
                    delay: 1000,
                    callback: () => {
                        if (!this.gamePaused) {
                            this.gameTime++;
                            updateUI();
                        }
                    },
                    loop: true
                });

                this.spawnTimer = 0;
            }

            createBackground() {
                // Î≥Ñ Î†àÏù¥Ïñ¥ (3Ï∏µ)
                for (let layer = 0; layer < 3; layer++) {
                    const speed = (layer + 1) * 20;
                    for (let i = 0; i < 150; i++) {
                        const star = this.add.sprite(
                            Phaser.Math.Between(0, config.width),
                            Phaser.Math.Between(0, config.height),
                            'star'
                        );
                        star.setAlpha(0.3 + layer * 0.2);
                        star.setScale(0.5 + layer * 0.3);
                        star.setData('speed', speed);
                        star.setData('layer', layer);
                    }
                }

                // ÎÑ§Î∑∏Îùº Ìö®Í≥º (Í∑∏ÎùºÎç∞Ïù¥ÏÖò Ïõê)
                for (let i = 0; i < 5; i++) {
                    const nebula = this.add.circle(
                        Phaser.Math.Between(0, config.width),
                        Phaser.Math.Between(0, config.height),
                        Phaser.Math.Between(100, 300),
                        Phaser.Math.RND.pick([0x330066, 0x003366, 0x006633]),
                        0.1
                    );
                    nebula.setBlendMode(Phaser.BlendModes.ADD);
                }
            }

            initGame() {
                this.gameRunning = true;
                this.gamePaused = false;
                this.gameTime = 0;
                this.kills = 0;

                this.playerData = {
                    hp: 150,
                    maxHp: 150,
                    level: 1,
                    exp: 0,
                    expToNext: 100
                };

                this.weapons = [
                    { type: 'laser', lastShot: 0 }
                ];

                this.weaponTypes = this.createWeaponTypes();
            }

            createWeaponTypes() {
                return {
                    laser: {
                        name: 'Î†àÏù¥Ï†Ä Ìè¨', icon: 'üî´', desc: 'Ï†ÑÎ∞©ÏúÑ Î†àÏù¥Ï†Ä',
                        damage: 10, cooldown: 250, level: 1, maxLevel: 8,
                        shoot: (scene, time) => {
                            const count = 2 + this.weaponTypes.laser.level;
                            for (let i = 0; i < count; i++) {
                                const angle = Math.random() * Math.PI * 2;
                                scene.createProjectile(angle, 'laser', 0x00ffff, 6, 
                                    this.weaponTypes.laser.damage * (1 + this.weaponTypes.laser.level * 0.5));
                            }
                        }
                    },
                    missile: {
                        name: 'Ïú†ÎèÑ ÎØ∏ÏÇ¨Ïùº', icon: 'üöÄ', desc: 'Ï†Å Ï∂îÏ†Å ÎØ∏ÏÇ¨Ïùº',
                        damage: 25, cooldown: 1000, level: 0, maxLevel: 6,
                        shoot: (scene, time) => {
                            if (scene.enemies.getLength() === 0) return;
                            const count = 1 + Math.floor(this.weaponTypes.missile.level / 2);
                            const enemies = scene.enemies.getChildren();
                            for (let i = 0; i < Math.min(count, enemies.length); i++) {
                                const target = enemies[i];
                                const angle = Phaser.Math.Angle.Between(
                                    scene.player.x, scene.player.y, target.x, target.y
                                );
                                const proj = scene.createProjectile(angle, 'missile', 0xff6600, 8,
                                    this.weaponTypes.missile.damage * (1 + this.weaponTypes.missile.level * 0.4));
                                proj.setData('target', target);
                                proj.setData('homing', true);
                            }
                        }
                    },
                    plasma: {
                        name: 'ÌîåÎùºÏ¶àÎßà Î≥º', icon: 'üí•', desc: 'Î∞©ÏÇ¨Ìòï ÌîåÎùºÏ¶àÎßà',
                        damage: 15, cooldown: 800, level: 0, maxLevel: 6,
                        shoot: (scene, time) => {
                            const count = 4 + this.weaponTypes.plasma.level * 2;
                            for (let i = 0; i < count; i++) {
                                const angle = (Math.PI * 2 / count) * i;
                                scene.createProjectile(angle, 'plasma', 0xff00ff, 10,
                                    this.weaponTypes.plasma.damage * (1 + this.weaponTypes.plasma.level * 0.3));
                            }
                        }
                    },
                    shield: {
                        name: 'ÏóêÎÑàÏßÄ Ïã§Îìú', icon: 'üõ°Ô∏è', desc: 'ÏµúÎåÄ Ï≤¥Î†• +30',
                        level: 0, maxLevel: 8,
                        apply: (scene) => {
                            scene.playerData.maxHp += 30;
                            scene.playerData.hp = Math.min(scene.playerData.hp + 30, scene.playerData.maxHp);
                        }
                    },
                    regen: {
                        name: 'Ïû¨ÏÉù', icon: 'üíö', desc: 'Ï≤¥Î†• ÌöåÎ≥µ +20',
                        level: 0, maxLevel: 10,
                        apply: (scene) => {
                            scene.playerData.hp = Math.min(scene.playerData.hp + 20, scene.playerData.maxHp);
                        }
                    },
                    damage: {
                        name: 'ÌôîÎ†• Ï¶ùÍ∞ï', icon: 'üí™', desc: 'Î™®Îì† Î¨¥Í∏∞ +10%',
                        level: 0, maxLevel: 15,
                        apply: (scene) => {}
                    }
                };
            }

            createProjectile(angle, type, color, size, damage) {
                const gfx = this.add.graphics();
                
                // Î∞úÏÇ¨Ï≤¥ Î™®Ïñë
                gfx.fillStyle(color);
                gfx.fillCircle(0, 0, size);
                
                // Ïô∏Í≥ΩÏÑ†
                gfx.lineStyle(2, color, 0.8);
                gfx.strokeCircle(0, 0, size + 2);
                
                // ÎÇ¥Î∂Ä ÏΩîÏñ¥
                gfx.fillStyle(0xffffff);
                gfx.fillCircle(0, 0, size * 0.5);
                
                const proj = this.add.container(this.player.x, this.player.y, [gfx]);
                this.physics.add.existing(proj);
                
                const speed = 400;
                proj.body.setVelocity(
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed
                );
                
                proj.setData('damage', damage);
                proj.setData('type', type);
                proj.setData('color', color);
                
                // Ìä∏Î†àÏùº ÌååÌã∞ÌÅ¥
                const trail = this.add.particles(0, 0, 'particle', {
                    speed: 0,
                    scale: { start: 0.5, end: 0 },
                    tint: color,
                    lifespan: 200,
                    frequency: 20,
                    follow: proj
                });
                proj.setData('trail', trail);
                
                this.projectiles.add(proj);
                
                // Ï†úÍ±∞ ÌÉÄÏù¥Î®∏
                this.time.delayedCall(3000, () => {
                    if (proj.active) {
                        trail.destroy();
                        proj.destroy();
                    }
                });
                
                return proj;
            }

            spawnEnemy() {
                const angle = Math.random() * Math.PI * 2;
                const distance = 700;
                const x = config.width / 2 + Math.cos(angle) * distance;
                const y = config.height / 2 + Math.sin(angle) * distance;
                
                const difficulty = 1 + this.gameTime / 60;
                const type = Phaser.Math.Between(0, 2);
                
                let enemy;
                if (type === 0) {
                    // Ïú°Í∞ÅÌòï Ï†Å
                    const gfx = this.add.graphics();
                    gfx.lineStyle(3, 0xff0000);
                    gfx.fillStyle(0xff3333);
                    gfx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const a = (Math.PI / 3) * i;
                        const px = Math.cos(a) * 20;
                        const py = Math.sin(a) * 20;
                        if (i === 0) gfx.moveTo(px, py);
                        else gfx.lineTo(px, py);
                    }
                    gfx.closePath();
                    gfx.fillPath();
                    gfx.strokePath();
                    
                    enemy = this.add.container(x, y, [gfx]);
                    enemy.setData('hp', 25 * difficulty);
                    enemy.setData('speed', 100);
                } else if (type === 1) {
                    // Ïã≠ÏûêÍ∞Ä Ï†Å
                    const gfx = this.add.graphics();
                    gfx.fillStyle(0xff6600);
                    gfx.fillRect(-5, -15, 10, 30);
                    gfx.fillRect(-15, -5, 30, 10);
                    gfx.lineStyle(2, 0xff3300);
                    gfx.strokeRect(-5, -15, 10, 30);
                    gfx.strokeRect(-15, -5, 30, 10);
                    
                    enemy = this.add.container(x, y, [gfx]);
                    enemy.setData('hp', 20 * difficulty);
                    enemy.setData('speed', 140);
                } else {
                    // Îã§Ïù¥ÏïÑÎ™¨Îìú Ï†Å
                    const gfx = this.add.graphics();
                    gfx.lineStyle(3, 0xaa00aa);
                    gfx.fillStyle(0xff00ff);
                    gfx.beginPath();
                    gfx.moveTo(0, -20);
                    gfx.lineTo(15, 0);
                    gfx.lineTo(0, 20);
                    gfx.lineTo(-15, 0);
                    gfx.closePath();
                    gfx.fillPath();
                    gfx.strokePath();
                    
                    enemy = this.add.container(x, y, [gfx]);
                    enemy.setData('hp', 40 * difficulty);
                    enemy.setData('speed', 70);
                }
                
                enemy.setData('maxHp', enemy.getData('hp'));
                enemy.setData('damage', 3);
                
                this.physics.add.existing(enemy);
                enemy.body.setCircle(20);
                this.enemies.add(enemy);
            }

            update(time, delta) {
                if (!this.gameRunning || this.gamePaused) return;

                // Î¨¥Í∏∞ Î∞úÏÇ¨
                this.weapons.forEach(weapon => {
                    const wData = this.weaponTypes[weapon.type];
                    if (wData.shoot && time - weapon.lastShot > wData.cooldown) {
                        wData.shoot(this, time);
                        weapon.lastShot = time;
                    }
                });

                // Î∞úÏÇ¨Ï≤¥ ÏóÖÎç∞Ïù¥Ìä∏
                this.projectiles.getChildren().forEach(proj => {
                    // Ïú†ÎèÑ ÎØ∏ÏÇ¨Ïùº
                    if (proj.getData('homing')) {
                        const target = proj.getData('target');
                        if (target && target.active) {
                            const angle = Phaser.Math.Angle.Between(
                                proj.x, proj.y, target.x, target.y
                            );
                            const speed = 400;
                            proj.body.setVelocity(
                                Math.cos(angle) * speed,
                                Math.sin(angle) * speed
                            );
                        }
                    }

                    // ÌôîÎ©¥ Î∞ñ Ï†úÍ±∞
                    if (Phaser.Math.Distance.Between(proj.x, proj.y, config.width/2, config.height/2) > 1000) {
                        const trail = proj.getData('trail');
                        if (trail) trail.destroy();
                        proj.destroy();
                    }
                });

                // Ï†Å ÏóÖÎç∞Ïù¥Ìä∏
                this.enemies.getChildren().forEach(enemy => {
                    // ÌîåÎ†àÏù¥Ïñ¥ Ï∂îÏ†Å
                    this.physics.moveToObject(enemy, this.player, enemy.getData('speed'));
                    
                    // ÌöåÏ†Ñ
                    enemy.rotation += 0.02;

                    // Ï∂©Îèå Ï≤¥ÌÅ¨ (ÌîåÎ†àÏù¥Ïñ¥)
                    const dist = Phaser.Math.Distance.Between(
                        enemy.x, enemy.y, this.player.x, this.player.y
                    );
                    if (dist < 40) {
                        this.playerData.hp -= enemy.getData('damage');
                        this.createExplosion(enemy.x, enemy.y, 0xff0000);
                        this.cameras.main.shake(100, 0.005);
                        enemy.destroy();
                        
                        if (this.playerData.hp <= 0) {
                            this.gameOver();
                        }
                    }

                    // Ï∂©Îèå Ï≤¥ÌÅ¨ (Î∞úÏÇ¨Ï≤¥)
                    this.projectiles.getChildren().forEach(proj => {
                        const pdist = Phaser.Math.Distance.Between(
                            proj.x, proj.y, enemy.x, enemy.y
                        );
                        if (pdist < 25) {
                            const damage = proj.getData('damage') * (1 + this.weaponTypes.damage.level * 0.1);
                            enemy.setData('hp', enemy.getData('hp') - damage);
                            
                            this.createHitEffect(enemy.x, enemy.y, proj.getData('color'));
                            
                            const trail = proj.getData('trail');
                            if (trail) trail.destroy();
                            proj.destroy();
                            
                            if (enemy.getData('hp') <= 0) {
                                this.kills++;
                                this.createExplosion(enemy.x, enemy.y, 0xffff00);
                                this.spawnXP(enemy.x, enemy.y);
                                enemy.destroy();
                                
                                this.playerData.exp += 10;
                                if (this.playerData.exp >= this.playerData.expToNext) {
                                    this.levelUp();
                                }
                            }
                        }
                    });
                });

                // XP Ïò§Î∏å ÏóÖÎç∞Ïù¥Ìä∏
                this.xpOrbs.getChildren().forEach(orb => {
                    const dist = Phaser.Math.Distance.Between(
                        orb.x, orb.y, this.player.x, this.player.y
                    );
                    if (dist < 150) {
                        this.physics.moveToObject(orb, this.player, 300);
                    }
                    if (dist < 30) {
                        orb.destroy();
                    }
                });

                // Ï†Å Ïä§Ìè∞
                const spawnRate = Math.max(300 - this.gameTime * 8, 100);
                this.spawnTimer += delta;
                if (this.spawnTimer > spawnRate) {
                    this.spawnEnemy();
                    this.spawnTimer = 0;
                }

                updateUI();
            }

            createHitEffect(x, y, color) {
                const particles = this.add.particles(x, y, 'particle', {
                    speed: { min: 50, max: 150 },
                    scale: { start: 0.6, end: 0 },
                    tint: color,
                    lifespan: 300,
                    quantity: 8
                });
                this.time.delayedCall(400, () => particles.destroy());
            }

            createExplosion(x, y, color) {
                const particles = this.add.particles(x, y, 'particle', {
                    speed: { min: 100, max: 300 },
                    scale: { start: 1, end: 0 },
                    tint: [color, 0xff6600, 0xffffff],
                    lifespan: 500,
                    quantity: 30
                });
                
                const flash = this.add.circle(x, y, 40, color, 0.8);
                this.tweens.add({
                    targets: flash,
                    scale: 3,
                    alpha: 0,
                    duration: 300,
                    onComplete: () => flash.destroy()
                });
                
                this.time.delayedCall(600, () => particles.destroy());
            }

            spawnXP(x, y) {
                const gfx = this.add.graphics();
                gfx.lineStyle(2, 0x00ff00);
                gfx.fillStyle(0x00ff88);
                gfx.fillStar(0, 0, 5, 8, 12);
                gfx.strokeStar(0, 0, 5, 8, 12);
                
                const orb = this.add.container(x, y, [gfx]);
                this.physics.add.existing(orb);
                this.xpOrbs.add(orb);
                
                this.tweens.add({
                    targets: orb,
                    scale: { from: 1, to: 1.3 },
                    duration: 500,
                    yoyo: true,
                    repeat: -1
                });
            }

            levelUp() {
                this.playerData.level++;
                this.playerData.exp -= this.playerData.expToNext;
                this.playerData.expToNext = Math.floor(this.playerData.expToNext * 1.2);
                this.gamePaused = true;
                
                showLevelUp(this);
            }

            gameOver() {
                this.gameRunning = false;
                const minutes = Math.floor(this.gameTime / 60);
                const seconds = this.gameTime % 60;
                document.getElementById('finalTime').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                document.getElementById('finalKills').textContent = this.kills;
                document.getElementById('finalLevel').textContent = this.playerData.level;
                document.getElementById('gameOver').style.display = 'block';
            }
        }

        const config = {
            type: Phaser.AUTO,
            width: window.innerWidth,
            height: window.innerHeight,
            parent: 'game-container',
            backgroundColor: '#0a0a1a',
            physics: {
                default: 'arcade',
                arcade: { gravity: { y: 0 }, debug: false }
            },
            scene: GameScene
        };

        const phaserGame = new Phaser.Game(config);
        let currentScene;

        function updateUI() {
            if (!currentScene) currentScene = phaserGame.scene.scenes[0];
            const p = currentScene.playerData;
            
            document.getElementById('hpText').textContent = `${Math.ceil(p.hp)}/${p.maxHp}`;
            document.getElementById('hpBar').style.width = (p.hp / p.maxHp * 100) + '%';
            document.getElementById('expText').textContent = `${p.exp}/${p.expToNext}`;
            document.getElementById('expBar').style.width = (p.exp / p.expToNext * 100) + '%';
            document.getElementById('levelText').textContent = p.level;
            document.getElementById('killText').textContent = currentScene.kills;
            
            const minutes = Math.floor(currentScene.gameTime / 60);
            const seconds = currentScene.gameTime % 60;
            document.getElementById('timeText').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function showLevelUp(scene) {
            const modal = document.getElementById('levelUpModal');
            const options = document.getElementById('upgradeOptions');
            options.innerHTML = '';
            
            const available = Object.keys(scene.weaponTypes).filter(k => {
                const w = scene.weaponTypes[k];
                return !w.maxLevel || w.level < w.maxLevel;
            });
            
            const selected = [];
            while (selected.length < Math.min(5, available.length)) {
                const idx = Math.floor(Math.random() * available.length);
                selected.push(available[idx]);
                available.splice(idx, 1);
            }
            
            selected.forEach(key => {
                const weapon = scene.weaponTypes[key];
                const card = document.createElement('div');
                card.className = 'upgrade-card';
                card.innerHTML = `
                    <div class="upgrade-icon">${weapon.icon}</div>
                    <div class="upgrade-name">${weapon.name}</div>
                    <div class="upgrade-desc">${weapon.desc}</div>
                    <div class="level-display">Lv ${weapon.level} ‚Üí ${weapon.level + 1}</div>
                `;
                card.onclick = () => selectUpgrade(scene, key);
                options.appendChild(card);
            });
            
            modal.style.display = 'block';
        }

        function selectUpgrade(scene, key) {
            const weapon = scene.weaponTypes[key];
            weapon.level++;
            
            if (weapon.shoot && !scene.weapons.find(w => w.type === key)) {
                scene.weapons.push({ type: key, lastShot: 0 });
            }
            
            if (weapon.apply) {
                weapon.apply(scene);
            }
            
            document.getElementById('levelUpModal').style.display = 'none';
            scene.gamePaused = false;
        }

        window.addEventListener('resize', () => {
            phaserGame.scale.resize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>